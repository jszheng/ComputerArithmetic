
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Computer Arithmetic - Algorithms and Hardware Designs">
      
      
      
        <link rel="canonical" href="https://jszheng.github.io/ComputerArithmetic/Part_01/03/">
      
      
        <link rel="prev" href="../02/">
      
      
        <link rel="next" href="../04/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.19">
    
    
      
        <title>3. 冗余数系统 - 计算机算术-算法与硬件实现</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.eebd395e.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300i,400,400i,700,700i%7CFira+Code:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Noto Sans SC";--md-code-font:"Fira Code"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#3" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="计算机算术-算法与硬件实现" class="md-header__button md-logo" aria-label="计算机算术-算法与硬件实现" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 89 89">
  <path d="M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z" />
  <path d="M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z" style="fill-opacity: 0.5" />
  <path d="M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z" />
  <path d="M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z" style="fill-opacity: 0.25" />
</svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            计算机算术-算法与硬件实现
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              3. 冗余数系统
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
            
              <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7.5 2c-1.79 1.15-3 3.18-3 5.5s1.21 4.35 3.03 5.5C4.46 13 2 10.54 2 7.5A5.5 5.5 0 0 1 7.5 2m11.57 1.5 1.43 1.43L4.93 20.5 3.5 19.07 19.07 3.5m-6.18 2.43L11.41 5 9.97 6l.42-1.7L9 3.24l1.75-.12.58-1.65L12 3.1l1.73.03-1.35 1.13.51 1.67m-3.3 3.61-1.16-.73-1.12.78.34-1.32-1.09-.83 1.36-.09.45-1.29.51 1.27 1.36.03-1.05.87.4 1.31M19 13.5a5.5 5.5 0 0 1-5.5 5.5c-1.22 0-2.35-.4-3.26-1.07l7.69-7.69c.67.91 1.07 2.04 1.07 3.26m-4.4 6.58 2.77-1.15-.24 3.35-2.53-2.2m4.33-2.7 1.15-2.77 2.2 2.54-3.35.23m1.15-4.96-1.14-2.78 3.34.24-2.2 2.54M9.63 18.93l2.77 1.15-2.53 2.19-.24-3.34Z"/></svg>
              </label>
            
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="grey" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
            
              <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7.5 2c-1.79 1.15-3 3.18-3 5.5s1.21 4.35 3.03 5.5C4.46 13 2 10.54 2 7.5A5.5 5.5 0 0 1 7.5 2m11.57 1.5 1.43 1.43L4.93 20.5 3.5 19.07 19.07 3.5m-6.18 2.43L11.41 5 9.97 6l.42-1.7L9 3.24l1.75-.12.58-1.65L12 3.1l1.73.03-1.35 1.13.51 1.67m-3.3 3.61-1.16-.73-1.12.78.34-1.32-1.09-.83 1.36-.09.45-1.29.51 1.27 1.36.03-1.05.87.4 1.31M19 13.5a5.5 5.5 0 0 1-5.5 5.5c-1.22 0-2.35-.4-3.26-1.07l7.69-7.69c.67.91 1.07 2.04 1.07 3.26m-4.4 6.58 2.77-1.15-.24 3.35-2.53-2.2m4.33-2.7 1.15-2.77 2.2 2.54-3.35.23m1.15-4.96-1.14-2.78 3.34.24-2.2 2.54M9.63 18.93l2.77 1.15-2.53 2.19-.24-3.34Z"/></svg>
              </label>
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/jszheng/ComputerArithmetic" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    jszheng/ComputerArithmetic
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="计算机算术-算法与硬件实现" class="md-nav__button md-logo" aria-label="计算机算术-算法与硬件实现" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 89 89">
  <path d="M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z" />
  <path d="M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z" style="fill-opacity: 0.5" />
  <path d="M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z" />
  <path d="M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z" style="fill-opacity: 0.25" />
</svg>

    </a>
    计算机算术-算法与硬件实现
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jszheng/ComputerArithmetic" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    jszheng/ComputerArithmetic
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        封面
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Front/" class="md-nav__link">
        标题
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Preface_1st/" class="md-nav__link">
        第一版序言
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Preface_2nd/" class="md-nav__link">
        第二版序言
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../">Part-I &nbsp; 数字的表示方法</a>
          
            <label for="__nav_5">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Part-I &nbsp; 数字的表示方法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../01/" class="md-nav__link">
        1. 数字与算术
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../02/" class="md-nav__link">
        2. 有符号数的表示
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          3. 冗余数系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        3. 冗余数系统
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 处理进位问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 计算机算术中的冗余
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    3.3 数字集和数字集转换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    3.4 广义有符号数字数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    3.5 无进位加法算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#36" class="md-nav__link">
    3.6 转换和支持功能
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    问题（略）
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    参考文献和进一步阅读
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../04/" class="md-nav__link">
        4 剩余数系统
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../Part_02/">Part-II &nbsp; 加法与减法</a>
          
            <label for="__nav_6">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Part-II &nbsp; 加法与减法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_02/05/" class="md-nav__link">
        5. 基础的加法与计数方案
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_02/06/" class="md-nav__link">
        6. 超前进位加法器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_02/07/" class="md-nav__link">
        7. 其它高速加法器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_02/08/" class="md-nav__link">
        8. 多操作数加法
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../Part_03/">Part-III &nbsp; 乘法</a>
          
            <label for="__nav_7">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Part-III &nbsp; 乘法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_03/09/" class="md-nav__link">
        9. 基础的乘法方案
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_03/10/" class="md-nav__link">
        10. 高基乘法器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_03/11/" class="md-nav__link">
        11. 树型乘法器与阵列乘法器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_03/12/" class="md-nav__link">
        12. 其它乘法器
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../Part_04/">Part-IV &nbsp; 除法</a>
          
            <label for="__nav_8">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          Part-IV &nbsp; 除法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_04/13/" class="md-nav__link">
        13. 基础除法方案
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_04/14/" class="md-nav__link">
        14. 高基除法器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_04/15/" class="md-nav__link">
        15. 其它除法器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_04/16/" class="md-nav__link">
        16. 除法的收敛算法
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../Part_05/">Part-V &nbsp; 实数算数</a>
          
            <label for="__nav_9">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_9">
          <span class="md-nav__icon md-icon"></span>
          Part-V &nbsp; 实数算数
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_05/17/" class="md-nav__link">
        17. 浮点数表示
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_05/18/" class="md-nav__link">
        18. 浮点数运算
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_05/19/" class="md-nav__link">
        19. 误差与误差控制
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_05/20/" class="md-nav__link">
        20. 精确可靠的算术
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../Part_06/">Part_VI &nbsp; 特殊函数求值</a>
          
            <label for="__nav_10">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_10">
          <span class="md-nav__icon md-icon"></span>
          Part_VI &nbsp; 特殊函数求值
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_06/21/" class="md-nav__link">
        21. 平方根算法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_06/22/" class="md-nav__link">
        22. CORDIC算法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_06/23/" class="md-nav__link">
        23. 其它函数求值方法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_06/24/" class="md-nav__link">
        24. 查表法算术
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../Part_07/">Part_VII &nbsp; 实现相关主题</a>
          
            <label for="__nav_11">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_11">
          <span class="md-nav__icon md-icon"></span>
          Part_VII &nbsp; 实现相关主题
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_07/25/" class="md-nav__link">
        25. 高吞吐量算术
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_07/26/" class="md-nav__link">
        26. 低功耗算术
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_07/27/" class="md-nav__link">
        27. 容错算术
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Part_07/28/" class="md-nav__link">
        28. 可重构算术
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Appendix/" class="md-nav__link">
        附录
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../BackCover/" class="md-nav__link">
        封底
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 处理进位问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 计算机算术中的冗余
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    3.3 数字集和数字集转换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    3.4 广义有符号数字数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    3.5 无进位加法算法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#36" class="md-nav__link">
    3.6 转换和支持功能
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    问题（略）
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    参考文献和进一步阅读
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
    <a href="https://github.com/jszheng/ComputerArithmetic/blob/master/docs/Part_01/03.md" title="编辑此页" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4v-2m10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1 2.1 2.1Z"/></svg>
    </a>
  
  


<h1 id="3">3. 冗余数系统<a class="headerlink" href="#3" title="Permanent link">&para;</a></h1>
<p>Redundant Number Systems</p>
<blockquote>
<p><em>“Numbers constitute the only universal language.”</em> </p>
<p>— NATHANAE LWEST</p>
<p>“数字构成了唯一的通用语言。”</p>
<p>— 纳撒尼尔·韦斯特</p>
</blockquote>
<p>This chapter deals with the representation of signed fixed-point numbers using a positive integer radix  <em>r</em>  and a redundant digit set composed of more than  <em>r</em>  digit values. After showing that such representations eliminate carry propagation, we cover variations in digit sets, addition algorithms, input/output conversions, and arithmetic support functions. Chapter topics include:</p>
<p>本章讨论有符号定点数使用正整数基数r和由多于r个数字值组成的冗余数字集的表示法。在证明这种表示消除了进位传播之后，我们介绍了数字集、加法算法、输入/输出转换和算术支持函数的变化。章节主题包括：</p>
<p><strong>3.1</strong> 处理进位问题 Coping with the Carry Problem</p>
<p><strong>3.2</strong> 计算机算术中的冗余 Redundancy in Computer Arithmetic</p>
<p><strong>3.3</strong> 数字集和数字集转换Digit Sets and Digit-Set Conversions</p>
<p><strong>3.4</strong> 广义的有符号数字数 Generalized Signed-Digit Numbers</p>
<p><strong>3.5</strong> 无进位加法算法 Carry-Free Addition Algorithms</p>
<p><strong>3.6</strong> 转换和支持功能 Conversions and Support Functions</p>
<h2 id="31">3.1 处理进位问题<a class="headerlink" href="#31" title="Permanent link">&para;</a></h2>
<p>Addition is a primary building block in implementing arithmetic operations. If addition is slow or expensive, all other operations suffer in speed or cost. Addition can be slow and/or expensive because:</p>
<p><strong>a.</strong> With  <em>k</em>-digit operands, one has to allow for O( <em>k</em>) worst-case carry-propagation stages in simple ripple-carry adder design. </p>
<p><strong>b.</strong> The carry computation network is a major source of complexity and cost in the design of carry-lookahead and other fast adders. </p>
<p>The carry problem can be dealt with in several ways:</p>
<p><strong>1.</strong> Limit carry propagation to within a small number of bits. </p>
<p><strong>2.</strong> Detect the end of propagation rather than wait for worst-case time. </p>
<p><strong>3.</strong> Speed up propagation via lookahead and other methods. </p>
<p><strong>4.</strong> Ideal: Eliminate carry propagation altogether! </p>
<p>加法是实现算术运算的主要构建块。如果加法速度慢或成本高，则所有其他操作的速度或成本都会受到影响。加法可能会很慢和/或昂贵是因为：</p>
<p><strong>a.</strong> 对于 k 位操作数，在简单的纹波进位加法器设计中必须考虑到 O(k) 个最坏情况的进位传播阶段。</p>
<p><strong>b.</strong> 进位计算网络是超前进位和其他快速加法器设计中复杂性和成本的主要来源。</p>
<p>进位问题可以通过多种方式处理：</p>
<ol>
<li>
<p>将进位传播限制在少量位内。</p>
</li>
<li>
<p>检测传播的结束而不是等待最坏情况的时间。</p>
</li>
<li>
<p>通过超前看和其他方法加速传播。</p>
</li>
<li>
<p>理想：完全消除进位传播！</p>
</li>
</ol>
<p>As examples of option 1, hybrid-redundant and residue number system representations are covered in Section 3.4 and Chapter 4, respectively. Asynchronous adder design (option 2) is considered in Section 5.4. Speedup methods for carry propagation are covered in Chapters 6 and 7. </p>
<p>In the remainder of this chapter, we deal with option 4, focusing first on the question: Can numbers be represented in such a way that addition does not involve carry propagation? We will see shortly that this is indeed possible. The resulting number representations can be used as the primary encoding scheme in the design of high-performance systems and are also useful in representing intermediate results in machines that use conventional number representation. </p>
<p>作为选项 1 的示例，第 3.4 节和第 4 章分别介绍了混合冗余和残数系统表示。第 5.4 节考虑了异步加法器设计（选项 2）。第 6 章和第 7 章介绍了进位传播的加速方法。</p>
<p>在本章的其余部分，我们将讨论选项 4，首先关注这个问题：数字是否可以用加法不涉及进位传播的方式表示？我们很快就会看到这确实是可能的。由此产生的数字表示可以用作高性能系统设计中的主要编码方案，并且也可用于表示使用传统数字表示的机器中的中间结果。</p>
<p>We begin with a decimal example  <em>(r</em> = 10 <em>)</em>, assuming the standard digit set [0, 9].  Consider the addition of the following two decimal numbers without carry propagation.  For this, we simply compute “position sums” and write them down in the corresponding columns. We can use the symbols  <em>A</em> = 10,  <em>B</em> = 11,  <em>C</em> = 12, etc., for the extended digit values or simply represent them with two standard digits. </p>
<p>我们从一个十进制示例 (r = 10) 开始，假设标准数字集 [0, 9]。 考虑以下两个十进制数相加而不进行进位传播。为此，我们只需计算“位置总和”并将其写在相应的列中。我们可以使用符号 A = 10、B = 11、C = 12 等来表示扩展数字值，或者简单地用两个标准数字来表示它们。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>   5  7  8  2  4  9
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>+  6  2  9  3  8  9     Operand digits in [0, 9]
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>----------------------------------------------------
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>  11  9 17  5 12 18     Position sums in [0, 18]
</code></pre></div>
<p>So, if we allow the digit set [0, 18], the scheme works, but only for the first addition! Subsequent additions will cause problems. </p>
<p>因此，如果我们允许数字集 [0, 18]，则该方案有效，但仅适用于第一次加法！后续添加会出现问题。</p>
<p>Consider now adding two numbers in the radix-10 number system using the digit set [0, 18]. The sum of digits for each position is in [0, 36], which can be decomposed into an interim sum in [0, 16] and a transfer digit in [0, 2]. In other words</p>
<p>现在考虑使用数字集[0, 18]将基 10 数字系统中的两个数字相加。每个位置的数字和在[0, 36]中，可以分解为[0, 16]中的中间和和[0, 2]中的转移数字。换句话说</p>
<p>​     [0, 36] = 10 × [0, 2] + [0, 16]</p>
<p>Adding the interim sum and the incoming transfer digit yields a digit in [0, 18] and creates no new transfer. In interval notation, we have</p>
<p>将临时总和与传入的传输数字相加会产生 [0, 18] 中的数字，并且不会创建新的传输。在区间表示法中，我们有</p>
<p>​    [0, 16] + [0, 2] = [0, 18]</p>
<p>Figure 3.1 shows an example addition. </p>
<p>图 3.1 显示了一个加法示例。</p>
<p><img alt="image-20230731100550048" src="../assets/image-20230731100550048.png" /></p>
<p>So, even though we cannot do true carry-free addition (Fig. 3.2a), the next best thing, where carry propagates by only one position (Fig. 3.2b), is possible if we use the digit set [0, 18] in radix 10. We refer to this best possible scheme as “carry-free” addition. The key to the ability to do carry-free addition is the representational redundancy that provides multiple encodings for some numbers. Figure 3.2c shows that the single-stage propagation of transfers can be eliminated by a simple lookahead scheme; that is, instead of first computing the transfer into position  <em>i</em>  based on the digits  <em>xi</em>−1 and  <em>yi</em>−1 and then combining it with the interim sum, we can determine  <em>si</em>  directly from  <em>xi</em>,  <em>yi</em>,  <em>xi</em>−1, and <em>yi</em>−1. This may make the adder logic somewhat more complex, but in general the result is higher speed. </p>
<p>因此，即使我们不能进行真正的无进位加法（图 3.2a），如果我们在基数 10 中使用数字集 [0, 18]，则下一个最好的方案是可能的，其中进位仅传播一个位置（图 3.2b）。我们将这种最佳可能方案称为“无进位”加法。进行无进位加法的能力的关键是表示冗余，它为某些数字提供了多种编码。图3.2c显示单级传输的传播可以通过简单的前瞻方案来消除；也就是说，我们可以直接根据 <span class="arithmatex">\(x_i、y_i、x_{i−1}\)</span> 和 <span class="arithmatex">\(y_{i−1}\)</span> 确定 <span class="arithmatex">\(s_i\)</span>，而不是首先根据数字 <span class="arithmatex">\(x_{i−1}\)</span> 和 <span class="arithmatex">\(y_{i−1}\)</span> 计算到位置 <span class="arithmatex">\(i\)</span> 的转移，然后将其与临时和相结合。这可能会使加法器逻辑更加复杂，但通常结果是速度更高。</p>
<p><img alt="image-20230731102718058" src="../assets/image-20230731102718058.png" /></p>
<p>In the decimal example of Fig. 3.1, the digit set [0, 18] was used to effect carry-free addition. The 9 “digit” values 10 through 18 are redundant. However, we really do not need this much redundancy in a decimal number system for carry-free addition; the digit set [0, 11] will do. Our example addition (after converting the numbers to the new digit set) is shown in Fig. 3.3. </p>
<p>在图 3.1 的十进制示例中，数字集 [0, 18] 用于实现无进位加法。 10 到 18 的 9 个“数字”值是冗余的。在十进制数字系统中，我们确实不需要这么多冗余来进行无进位加法；数字集 [0, 11] 即可。我们的加法示例（将数字转换为新的数字集之后）如图 3.3 所示。</p>
<p><img alt="image-20230731112933234" src="../assets/image-20230731112933234.png" /></p>
<p>A natural question at this point is: How much redundancy in the digit set is needed to enable carry-free addition? For example, will the example addition of Fig. 3.3 work with the digit set [0, 10]? (Try it and see.) We will answer this question in Section 3.5. </p>
<p>此时一个自然的问题是：数字集中需要多少冗余才能实现无进位加法？例如，图 3.3 中的加法示例是否适用于数字集 [0, 10]？ （尝试一下看看。）我们将在 3.5 节中回答这个问题。</p>
<h2 id="32">3.2 计算机算术中的冗余<a class="headerlink" href="#32" title="Permanent link">&para;</a></h2>
<p>Redundancy is used extensively for speeding up arithmetic operations. The oldest example, first suggested in 1959 [Metz59], pertains to carry-save or stored-carry numbers using the radix-2 digit set [0, 2] for fast addition of a sequence of binary operands. Figure 3.4 provides an example, showing how the intermediate sum is kept in stored-carry format, allowing each subsequent addition to be performed in a carry-free manner. </p>
<p>冗余被广泛用于加速算术运算。最古老的示例于 1959 年首次提出 [Metz59]，涉及使用基数 2 数字集 [0, 2] 进行二进制操作数序列的快速加法的进位保存或存储进位数。图 3.4 提供了一个示例，显示了中间和如何以存储进位格式保存，从而允许以无进位方式执行每个后续加法。</p>
<p><img alt="image-20230731113701021" src="../assets/image-20230731113701021.png" /></p>
<p>Why is this scheme called carry-save or stored-carry? Figure 3.5 provides an explanation. Let us use the 2-bit encoding</p>
<p>为什么这个方案被称为进位保存或存储进位？图 3.5 提供了一个解释。让我们使用2位编码</p>
<p>​      <strong>0</strong> :  (0, 0),  <strong>1</strong> : (0, 1) 或 (1, 0),  <strong>2</strong> :  (1, 1)</p>
<p>to represent the digit set [0, 2]. With this encoding, each stored-carry number is really composed of two binary numbers, one for each bit of the encoding. These two binary numbers can be added to an incoming binary number, producing two binary numbers composed of the sum bits kept in place and the carry bits shifted one position to the left. </p>
<p>表示数字集 [0, 2]。通过这种编码，每个存储进位数实际上由两个二进制数组成，每个二进制数对应编码的每一位。这两个二进制数可以与传入的二进制数相加，产生两个二进制数，其中和位保持在原位，进位位向左移动一位。</p>
<p>These sum and carry bits form the partial sum and can be stored in two registers for the next addition. Thus, the carries are “saved” or “stored” instead of being allowed to propagate. </p>
<p>这些和和进位位形成部分和，并且可以存储在两个寄存器中以供下一次加法使用。因此，进位被“保存”或“存储”，而不是被允许传播。</p>
<p><img alt="image-20230731113803211" src="../assets/image-20230731113803211.png" /></p>
<p>Figure 3.5 shows that one stored-carry number and one standard binary number can be added to form a stored-carry sum in a single full-adder delay (2–4 gate levels, depending on the full adder’s logic implementation of the outputs  <em>s</em> =  <em>x</em> ⊕  <em>y</em> ⊕  <em>c</em> in and <em>c</em> out =  <em>xy</em>∨ <em>xc</em> in ∨ <em>yc</em> in <em>)</em>. This is significantly faster than standard carry-propagate addition to accumulate the sum of several binary numbers, even if a fast carry-lookahead adder is used for the latter. Of course once the final sum has been obtained in stored-carry form, it may have to be converted to standard binary by using a carry-propagate adder to add the two components of the stored-carry number. The key point is that the carry-propagation delay occurs only once, at the very end, rather than in each addition step. </p>
<p>图3.5显示了1个存储进位数和1个标准二进制数可以相加得到存储进位数，需要单个全加器延迟（2-4 个门级，取决于全加器的输出逻辑实现 s = x ⊕ y ⊕ c in 和 c out = xy∨ xc in ∨ yc in ）。这比累加几个二进制数之和的标准进位传播加法要快得多，即使后者使用快速进位超前加法器也是如此。当然，一旦以存储进位形式获得最终总和，可能必须使用进位传播加法器将存储进位数的两个分量相加，将其转换为标准二进制。关键点是进位传播延迟仅在最后发生一次，而不是在每个加法步骤中发生。</p>
<p>Since the carry-save addition scheme of Fig. 3.5 converts three binary numbers to two binary numbers with the same sum, it is sometimes referred to as a 3/2 reduction circuit or (3; 2) counter. The latter name reflects the essential function of a full adder: it counts the number of 1s among its three input bits and outputs the result as a 2-bit binary number. More on this in Chapter 8. </p>
<p>由于图 3.5 的进位保存加法方案将三个二进制数转换为具有相同和的两个二进制数，因此有时将其称为 3/2 归约电路或 (3; 2) 计数器。后一个名称反映了全加器的基本功能：它计算三个输入位中 1 的数量，并将结果作为 2 位二进制数输出。更多内容请参见第 8 章。</p>
<p>Other examples of the use of redundant representations in computer arithmetic are found in fast multiplication and division schemes, where the multiplier or quotient is represented or produced in redundant form. More on these in Parts III and IV. </p>
<p>在计算机算术中使用冗余表示的其他示例可以在快速乘法和除法方案中找到，其中乘数或商以冗余形式表示或产生。有关这些的更多信息，请参见第三部分和第四部分。</p>
<h2 id="33">3.3 数字集和数字集转换<a class="headerlink" href="#33" title="Permanent link">&para;</a></h2>
<p>Conventional radix- <em>r</em> numbers use the standard digit set [0, <em>r</em> − 1]. However, many other redundant and nonredundant digit sets are possible. A necessary condition is that the digit set contain at least <em>r</em> different digit values. If it contains more than <em>r</em> values, the number system is redundant.</p>
<p>传统的基数 r 数字使用标准数字集 <span class="arithmatex">\([0, r − 1]\)</span>。然而，许多其他冗余和非冗余数字集也是可能的。必要条件是数字集合至少包含r个不同的数字值。如果它包含多于 r 值，则数字系统是冗余的。</p>
<p>Conversion of numbers between standard and other digit sets is quite simple and essentially entails a digit-serial process in which, beginning at the right end of the given number, each digit is rewritten as a valid digit in the new digit set and a transfer (carry or borrow) into the next higher digit position. This conversion process is essentially like carry propagation in that it must be done from right to left and, in the worst case, the most significant digit is affected by a “carry” coming from the least significant position. The following examples illustrate the process (see also the examples at the end of Section 2.6).</p>
<p>标准数字集和其他数字集之间的数字转换非常简单，本质上需要一个数字串行过程，其中从给定数字的右端开始，每个数字都被重写为新数字集中的有效数字，并转移（进位或借位）到下一个更高的数字位置。此转换过程本质上类似于进位传播，因为它必须从右到左完成，并且在最坏的情况下，最高有效数字会受到来自最低有效位置的“进位”的影响。以下示例说明了该过程（另请参见第 2.6 节末尾的示例）。</p>
<p><strong>EXAMPLE 3.1</strong> Convert the following radix-10 number with the digit set [0, 18] to one using the conventional digit set [0, 9].</p>
<p><strong>示例3.1</strong> 将以下数字集[0, 18] 的基10 数转换为使用传统数字集[0, 9] 的。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>  11  9 17 10 12 18   Rewrite 18 as 10 (carry 1) +8
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>  11  9 17 10 13  8   13 = 10 (carry 1) + 3
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>  11  9 17 11  3  8   11 = 10 (carry 1) + 1
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>  11  9 18  1  3  8   18 = 10 (carry 1) + 8
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>  11 10  8  1  3  8   10 = 10 (carry 1) + 0
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>  12  0  8  1  3  8   12 = 10 (carry 1) + 2
<a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a>1  2  0  8  1  3  8   Answer: all digits in [0, 9]
</code></pre></div>
<p><strong>EXAMPLE 3.2</strong> Convert the following radix-2 carry-save number to binary; that is, from digit set [0, 2] to digit set [0, 1].</p>
<p><strong>示例3.2</strong> 将以下基2 进位保存数转换为二进制；即从数字集[0, 2]到数字集[0, 1]。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>  1 1 2 0 2 0   Rewrite 2 as 2 (carry 1) + 0
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a>  1 1 2 1 0 0   2 = 2 (carry 1) + 0
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>  1 2 0 1 0 0   2 = 2 (carry 1) + 0
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>  2 0 0 1 0 0   2 = 2 (carry 1) + 0
<a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a>1 0 0 0 1 0 0   Answer: all digits in [0, 1]
</code></pre></div>
<p>Another way to accomplish the preceding conversion is to decompose the carry-save number into two numbers, both of which have 1s where the original number has a digit of 2. The sum of these two numbers is then the desired binary number.</p>
<p>完成上述转换的另一种方法是将进位保存数分解为两个数，这两个数都是 1，而原始数的位数为 2。这两个数的和就是所需的二进制数。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>  1 1 1 0 1 0 First number: “sum” bits
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>+ 0 0 1 0 1 0 Second number: “carry” bits
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>--------------------------------------------
<a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a>1 0 0 0 1 0 0 Sum of the two numbers
</code></pre></div>
<p><strong>EXAMPLE 3.3</strong> Digit values do not have to be positive. We reconsider Example 3.1 using the asymmetric target digit set [−6, 5].</p>
<p><strong>示例3.3</strong> 数字值不必是正数。我们使用不对称目标数字集 [−6, 5] 重新考虑示例 3.1。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>   11   9  17  10  12  18    Rewrite 18 as 20 (carry 2) − 2
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>   11   9  17  10  14  −2    14 = 10 (carry 1) + 4
<a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>   11   9  17  11   4  −2    11 = 10 (carry 1) + 1
<a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>   11   9  18   1   4  −2    18 = 20 (carry 2) − 2
<a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>   11  11  −2   1   4  −2    11 = 10 (carry 1) + 1
<a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>   12   1  −2   1   4  −2    12 = 10 (carry 1) + 2
<a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a>1   2   1  −2   1   4  −2    Answer: all digits in [−6, 5]
</code></pre></div>
<p>On line 2 of this conversion, we could have rewritten 14 as 20 (carry 2) − 6, which would have led to a different, but equivalent, representation. In general, several representations may be possible with a redundant digit set.</p>
<p>在这个转换的第 2 行，我们可以将 14 重写为 20 (carry 2) − 6，这将导致不同但等效的表示。一般来说，冗余数字集可能有多种表示形式。</p>
<p><strong>EXAMPLE 3.4</strong> If we change the target digit set of Example 3.2 from [0, 1] to [−1, 1], we can do the conversion digit-serially as before. However, carry-free conversion is possible for this example if we rewrite each 2 as 2 (carry 1) + 0 and each 1 as 2 (carry 1) −1.</p>
<p><strong>例3.4</strong> 如果我们将例3.2 的目标数字集从[0, 1] 更改为[−1, 1]，我们可以像以前一样进行数字串行转换。然而，如果我们将每个 2 重写为 2 (进位 1) + 0，并将每个 1 重写为 2 (进位 1) -1，则在本示例中，无进位转换是可能的。</p>
<p>The resulting interim digits in [−1, 0] can absorb an incoming carry of 1 with no further propagation.</p>
<p>[−1, 0] 中产生的中间数字可以吸收传入的 1 进位，而不会进一步传播。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>   1  1  2  0  2  0  Given carry-save number
<a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>  −1 −1  0  0  0  0  Interim digits in [−1, 0]
<a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>   1  1  1  0  1  0  Transfer digits in [0, 1]
<a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>1  0  0  0  1  0  0  Answer: all digits in [−1, 1]
</code></pre></div>
<h2 id="34">3.4 广义有符号数字数<a class="headerlink" href="#34" title="Permanent link">&para;</a></h2>
<p>We have seen thus far that the digit set of a radix- <em>r</em>  positional number system need not be the standard set [0,  <em>r</em>−1]. Using the digit set [−1, 1] for radix-2 numbers was proposed by E. Collignon as early as 1897 [Glas81]. Whether this was just a mathematical curiosity, or motivated by an application or advantage, is not known. In the early 1960s, Avizienis [Aviz61] defined the class of signed-digit number systems with symmetric digit sets [− <em>α</em>,  <em>α</em>] and radix  <em>r &gt;</em>  2, where  <em>α</em>  is any integer in the range  <em>r/</em> 2 + 1 ≤  <em>α</em> ≤  <em>r</em> − 1.  These number systems allow at least 2 <em>r/</em> 2 + 3 digit values, instead of the minimum required  <em>r</em>  values, and are thus redundant. </p>
<p>到目前为止我们已经看到，基数 r 位置数系统的数字集不一定是标准集 <span class="arithmatex">\([0, r−1]\)</span>。 E. Collignon 早在 1897 年就提出使用数字集 <span class="arithmatex">\([−1, 1]\)</span> 表示基 2 数 [Glas81]。这是否只是一种数学好奇心，还是出于应用或优势的动机，尚不清楚。 20 世纪 60 年代初，Avizienis [Aviz61] 定义了具有对称数字集的有符号数的数字系统类 <span class="arithmatex">\([− α, α]\)</span> 且基数 <span class="arithmatex">\(r &gt; 2\)</span>，其中 <span class="arithmatex">\(α\)</span> 是 <span class="arithmatex">\(\left \lfloor r/2 \right \rfloor + 1 ≤ α ≤ r − 1\)</span> 范围内的任意整数。这些数字系统允许至少 <span class="arithmatex">\(2 \left \lfloor r/2 \right \rfloor + 3\)</span> 位数字值，而不是所需的最小 r 值，因此是冗余的。</p>
<p>Subsequently, redundant number systems with general, possibly asymmetric, digit sets of the form [− <em>α</em>,  <em>β</em>] were studied as tools for unifying all redundant number representations used in practice. This class is called “<strong>generalized signed-digit (GSD)</strong> representation” and differs from the <strong>ordinary signed-digit (OSD)</strong> representation of Avizienis in its more general digit set as well as the possibility of higher or lower redundancy. </p>
<p>随后又有研究具有一般的、可能不对称的、形式为 <span class="arithmatex">\([− α, β]\)</span> 的数字集的冗余数系统，作为工具来统一实践中使用的所有冗余数表示。此类称为“广义符号数字 (GSD) 表示”，与 Avizienis 的普通符号数字 (OSD) 表示不同，其更通用的数字集以及更高或更低冗余的可能性。</p>
<p>Binary stored-carry numbers, with  <em>r</em> = 2 and digit set [0, 2], offer a good example for the usefulness of asymmetric digit sets. Higher redundancy is exemplified by the digit set [−7, 7] in radix 4 or [0, 3] in radix 2. An example for lower redundancy is the <strong>binary signed-digit (BSD)</strong> representation with  <em>r</em> = 2 and digit set [−1, 1]. None of these is covered by OSD. </p>
<p>二进制存储进位数，其中 r = 2 和数字集 [0, 2]，为非对称数字集的有用性提供了一个很好的例子。较高冗余的示例是基数 4 中的数字集 [−7, 7] 或基数 2 中的 [0, 3]。较低冗余的示例是二进制有符号数字 (BSD) 表示，其中 r = 2 和数字集 [−1, 1]。 OSD 不涵盖这些内容。</p>
<p>An important parameter of a GSD number system is its  <strong><em>redundancy index</em></strong>, defined as <em>ρ</em> =  <em>α</em> +  <em>β</em> + 1 −  <em>r</em> (i.e., the amount by which the size of its digit set exceeds the size  <em>r</em>  of a nonredundant digit set for radix  <em>r</em>). Figure 3.6 presents a taxonomy of redundant and nonredundant positional number systems showing the names of some useful subclasses and their various relationships. Note that the redundancy index  <em>ρ</em>  is quite general and can be applied to any digit set. Another way of quantifying the redundancy of a number system with the symmetric digit set [− <em>α</em>,  <em>α</em>] in radix  <em>r</em>  is to use the ratio  <em>h</em> =  <em>α/(r</em> − 1 <em>)</em>. This formulation of redundancy, which is inapplicable to the general digit set [− <em>α</em>,  <em>β</em>], has been used in connection with high-radix division algorithms, to be discussed in Chapter 14. Besides its general inapplicability, the index  <em>h</em>  suffers from the problem that it varies from 1 (for no redundancy), through 1 (for  <em>α</em> =  <em>r</em> − 1), to values larger than 1 for highly redundant number representation systems. Encountering redundancy indices below 1 is unusual and could be misleading.</p>
<p>GSD 数字系统的一个重要参数是其**冗余指数**，定义为 <span class="arithmatex">\(ρ = α + β + 1 − r\)</span>（即，其数字集的大小超过基数 r 的非冗余数字集的大小 r 的量）。图 3.6 展示了冗余和非冗余位置数字系统的分类，显示了一些有用子类的名称及其各种关系。请注意，冗余指数 ρ 非常通用，可以应用于任何数字集。度量具有基数 r 中的对称数字集 <span class="arithmatex">\([− α, α]\)</span> 的数字系统的冗余度的另一种方法是使用比率 <span class="arithmatex">\(h = α/(r − 1 )\)</span>。这种冗余公式不适用于一般数字集 <span class="arithmatex">\([− α, β]\)</span>，已与高基数除法算法结合使用，将在第 14 章中讨论。除了其一般不适用性之外，索引 h 还存在以下问题：它从 <span class="arithmatex">\(\frac{1}{2}\)</span>（对于无冗余）到 1（对于 α = r − 1）到大于 1 的值用于高度冗余的数字表示系统。遇到低于 1 的冗余指数是不寻常的，并且可能会产生误导。</p>
<p><img alt="image-20230731163656102" src="../assets/image-20230731163656102.png" /></p>
<p>Any hardware implementation of GSD arithmetic requires the choice of a binary encoding scheme for the  <em>α</em> +  <em>β</em> + 1 digit values in the digit set [− <em>α</em>,  <em>β</em>]. Multivalued logic realizations have been considered, but we limit our discussion here to binary logic and proceed to show the importance and implications of the encoding scheme chosen through some examples. </p>
<p>任何 GSD 算术的硬件实现都需要选择二进制的编码方案对数字集 <span class="arithmatex">\([− α, β]\)</span> 中 <span class="arithmatex">\(α + β + 1\)</span> 个数字值编码。已经考虑了多值逻辑实现，但我们将这里的讨论限制为二进制逻辑，并继续通过一些示例来展示所选择的编码方案的重要性和含义。</p>
<p>Consider, for example, the BSD number system with  <em>r</em> = 2 and the digit set [−1, 1]. One needs at least 2 bits to encode these three digit values. Figure 3.7 shows four of the many possible encodings that can be used. </p>
<p>例如，考虑 BSD 数字系统，其中 r = 2 和数字集 [−1, 1]。至少需要 2 位来对这三位数字值进行编码。图 3.7 显示了可以使用的多种可能编码中的四种。</p>
<p><img alt="image-20230731164652497" src="../assets/image-20230731164652497.png" /></p>
<p>With the ( <em>n</em>,  <em>p</em>) encoding, the code (1, 1) may be considered an alternate representation of 0 or else viewed as an invalid combination. Many implementations have shown that the ( <em>n</em>,  <em>p</em>) encoding tends to simplify the hardware and also increases the speed by reducing the number of gate levels [Parh88]. The 1-out-of-3 encoding requires more bits per number but allows the detection of some storage and processing errors. </p>
<p>对于 (n, p) 编码，代码 (1, 1) 可以被视为 0 的替代表示，或者被视为无效组合。许多实施表明( n, p) 编码倾向于简化硬件，并通过减少门级数量来提高速度 [Parh88]。 3 取 1 编码每个数字需要更多位，但允许检测一些存储和处理错误。</p>
<p>The  <em>(n</em>,  <em>p)</em>  and 2’s-complement encodings of Fig. 3.7 are examples of encodings in which two-valued signals having various weights collectively represent desired values. Figure 3.8a depicts three new symbols, besides <strong>posibits</strong> and <strong>negabits</strong> previously introduced in Figs. 1.4 and 2.13. A  <strong><em>doublebit</em></strong>  represents one of the two values in the set {0, 2}. A  <strong><em>negadoublebit</em></strong>  is a negatively weighted doublebit. Finally, a  <strong><em>unibit</em></strong>  assumes one of the two values in {−1, 1}. A posibit and a negabit together represent one of the values in the set {−1, 0, 1}, yielding the  <em>(n</em>,  <em>p)</em>  encoding of a BSD. A negadoublebit and a posibit form a 2-bit 2’s-complement number capable of representing a value in [−2, 1] and thus a BSD. These two encodings for a 5-digit BSD number are shown in Fig. 3.8b. The third representation in Fig. 3.8b is derived from the second one by shifting the negadoublebits to the left by one position and changing them into negabits. Each BSD digit now spans two digit positions in its encoding. These weighted bit-set encodings have been found quite useful for the efficient representation and processing of redundant numbers [Jabe05]. </p>
<p>图 3.7 的 (n, p) 和 2 补码编码是具有各种权重的二值信号共同表示期望值的编码示例。除了之前在图 1.4 和 2.13 中介绍的**正位**和**负位**之外，图 3.8a 还描述了三个新符号。 **双位**表示集合 {0, 2} 中的两个值之一。**负双位**是负加权双位。最后，一个单比特采用 {−1, 1} 中的两个值之一。正位和负位一起表示集合 {−1, 0, 1} 中的值之一，产生 BSD 的 (n, p) 编码。 negadoublebit 和 posibit 形成一个 2 位 2 的补码数，能够表示 [−2, 1] 中的值，从而表示 BSD。5 位 BSD 号码的这两种编码如图 3.8b 所示。图 3.8b 中的第三种表示法是从第二种表示法中导出的，方法是将负双位向左移动一位并将其更改为负位。每个 BSD 数字现在在其编码中跨越两个数字位置。人们发现这些加权位集编码对于冗余数的有效表示和处理非常有用[Jabe05]。</p>
<p><img alt="image-20230731165144424" src="../assets/image-20230731165144424.png" /></p>
<p>Hybrid signed-digit representations [Phat94] came about from an attempt to strike a balance between algorithmic speed and implementation cost by introducing redundancy in selected positions only. For example, standard binary representation may be used with BSD digits allowed in every third position, as shown in the addition example of Fig. 3.9. </p>
<p>混合符号数字表示法 [Phat94] 的产生是为了通过仅在选定位置引入冗余来在算法速度和实现成本之间取得平衡。例如，标准二进制表示可以与每第三个位置允许的 BSD 数字一起使用，如图 3.9 的加法示例所示。</p>
<p><img alt="image-20230731165213532" src="../assets/image-20230731165213532.png" /></p>
<p>The addition algorithm depicted in Fig. 3.9 proceeds as follows. First one completes the position sums  <em>pi</em>  that are in [0, 2] for standard binary and [−2, 2] in BSD positions. The BSD position sums are then broken into an interim sum  <em>wi</em>  and transfer  <em>ti</em>+1, both in [−1, 1]. For the interim sum digit, the value 1 (−1) is chosen only if it is certain that the incoming transfer cannot be 1 (−1); that is, when the two binary operand digits in position  <em>i</em> − 1 are (not) both 0s. The worst-case carry propagation spans a single group, beginning with a BSD that produces a transfer digit in [−1, 1] and ending with the next higher BSD position. </p>
<p>图 3.9 中描述的加法算法进行如下。第一个完成标准二进制的 [0, 2] 和 BSD 位置的 [−2, 2] 中的位置总和 <span class="arithmatex">\(p_i\)</span>。然后，BSD 位置和被分解为临时和 <span class="arithmatex">\(w_i\)</span> 并传输 <span class="arithmatex">\(t_{i+1}\)</span>，两者都在 [−1, 1] 中。对于临时和数位，仅当确定传入不能为 1 (−1) 时才选择值 1 (−1)；也就是说，当位置 <span class="arithmatex">\(i − 1\)</span> 中的两个二进制操作数数字（不是）都是 0 时。最坏情况的进位传播跨越单个组，从在 [−1, 1] 中产生传输数字的 BSD 开始，并以下一个更高的 BSD 位置结束。</p>
<p>More generally, the group size can be  <em>g</em>  rather than 3. A larger group size reduces the hardware complexity (since the adder block in a BSD position is more complex than that in other positions) but adds to the carry-propagation delay in the worst case; hence, the hybrid scheme offers a trade-off between speed and cost. </p>
<p>更一般地，组大小可以是 g 而不是 3。较大的组大小会降低硬件复杂性（因为 BSD 位置的加法器块比其他位置的加法器块更复杂），但在最坏的情况下会增加进位传播延迟；因此，混合方案提供了速度和成本之间的权衡。</p>
<p>Hybrid signed-digit representation with uniform spacing of BSD positions can be viewed as a special case of GSD systems. For the example of Fig. 3.9, arranging the numbers in 3-digit groups starting from the right end leads to a radix-8 GSD system with digit set [−4, 7]: that is, digit values from  <em>(</em>−1 0 0 <em>)</em> two to  <em>(</em> 1 1 1 <em>)</em> two. So the hybrid scheme of Fig. 3.9 can be viewed as an implementation of (digit encoding for) this particular radix-8 GSD representation. </p>
<p>具有均匀 BSD 位置间距的混合符号数字表示可以被视为 GSD 系统的特例。对于图 3.9 的示例，从右端开始将数字排列为 3 位组，得到一个数字集为 [−4, 7] 的基 8 GSD 系统：即从 (−1 0 0 ) 2 到 ( 1 1 1 ) 2 的数字值。因此，图 3.9 的混合方案可以被视为此特定基 8 GSD 表示（的数字编码）的实现。</p>
<p>The hybrid-redundant representation of Fig. 3.9, constituting an encoding for the radix-8 digit set [−4, 7], is depicted in Fig. 3.10 using extended dot notation. The asymmetry of the digit set, and thus of the number representation range, is an unfortunate feature of such representations that allow only posibits in nonredundant positions. By removing the latter restriction, we can obtain more desirable symmetric hybrid-redundant representations, exemplified by the second encoding of Fig. 3.10, which constitutes an encoding for the radix-8 digit set [−4, 4]. Arithmetic on all such extended hybrid-redundant representations can be performed with equal ease [Jabe06]. </p>
<p>图 3.9 的混合冗余表示构成了基数 8 数字集 [−4, 7] 的编码，在图 3.10 中使用扩展点表示法进行了描述。数字集的不对称性以及数字表示范围的不对称性是此类仅允许非冗余位置中的 pos 位的表示法的一个不幸特征。通过消除后一个限制，我们可以获得更理想的对称混合冗余表示，如图3.10的第二个编码所示，它构成了基8数字集[−4, 4]的编码。所有此类扩展混合冗余表示的算术都可以同样轻松地执行[Jabe06]。</p>
<p><img alt="image-20230731171048199" src="../assets/image-20230731171048199.png" /></p>
<h2 id="35">3.5 无进位加法算法<a class="headerlink" href="#35" title="Permanent link">&para;</a></h2>
<p>The GSD carry-free addition algorithm, corresponding to the scheme of Fig. 3.2b, is as follows:</p>
<p>GSD无进位加法算法，对应图3.2b的方案如下：</p>
<p><center><strong>Carry-free addition algorithm for GSD numbers</strong></center></p>
<ul>
<li>
<p>Compute the position sums <em>pi</em> = <em>xi</em> + <em>yi</em>.</p>
</li>
<li>
<p>Divide each <em>pi</em> into a transfer <em>ti</em>+1 and an interim sum <em>wi</em> = <em>pi</em> − <em>rti</em>+1.</p>
</li>
<li>
<p>Add the incoming transfers to obtain the sum digits <em>si</em> = <em>wi</em> + <em>ti</em>.</p>
</li>
</ul>
<p><center><strong>GSD 数字的无进位加法算法</strong></center></p>
<ul>
<li>
<p>计算位置总和 <span class="arithmatex">\(p_i = x_i + y_i\)</span>。</p>
</li>
<li>
<p>将每个 <span class="arithmatex">\(p_i\)</span> 分为进位 <span class="arithmatex">\(t_{i+1}\)</span> 与中间总和 <span class="arithmatex">\(w_i = p_i − rt_{i+1}\)</span>。</p>
</li>
<li>
<p>将传入传输相加以获得数字总和 <span class="arithmatex">\(s_i = w_i + t_i\)</span>。</p>
</li>
</ul>
<p>Let us assume that the transfer digits <em>ti</em> are from the digit set [− <em>λ</em>, <em>µ</em>]. To ensure that the last step leads to no new transfer, the following condition must be satisfied:</p>
<p>让我们假设传输数字 <span class="arithmatex">\(t_i\)</span> 来自数字集 <span class="arithmatex">\([− λ, µ]\)</span>。为了确保最后一步不会导致新的转移，必须满足以下条件：
$$
\begin{array}{c}
-\alpha+\lambda &amp; \le p_i-rt_{i+1} \le &amp; \beta-\mu \
| &amp; \text{ 中间和 } &amp; | \
\text{如果传入的−λ是可吸收的，最小的中间和} &amp; \text{} &amp; \text{如果传入的µ是可吸收的，最大的中间和}
\end{array}
$$
From the preceding inequalities, we can easily derive the conditions  <em>λ</em> ≥  <em>α/(r</em> − 1 <em>)</em> and  <em>µ</em> ≥  <em>β/(r</em> − 1 <em>)</em>. Once  <em>λ</em>  and  <em>µ</em>  are known, we choose the transfer digit value by comparing the position sum  <em>pi</em>  against  <em>λ</em> +  <em>µ</em> + 2 constants  <em>Cj</em>, − <em>λ</em> ≤  <em>j</em> ≤  <em>µ</em> + 1, with the transfer digit taken to be  <em>j</em>  if and only if  <em>Cj</em> ≤  <em>pi &lt; Cj</em>+1. Formulas giving possible values for these constants can be found in [Parh90]. Here, we describe a simple intuitive method for deriving these constants. </p>
<p>从前面的不等式，我们可以很容易地推导出条件 <span class="arithmatex">\(λ ≥ α/(r − 1 )\)</span> 和 <span class="arithmatex">\(µ ≥ β/(r − 1 )\)</span>。一旦已知 λ 和 µ，我们通过将位置总和 <span class="arithmatex">\(p_i\)</span> 与 <span class="arithmatex">\(λ + µ + 2\)</span> 常数 <span class="arithmatex">\(C_j\)</span> 进行比较来选择传输数字值，<span class="arithmatex">\(− λ ≤ j ≤ µ + 1\)</span>，当且仅当 <span class="arithmatex">\(C_j ≤ p_i &lt; C_{j+1}\)</span> 时，传输数字取为 j。给出这些常量可能值的公式可以在 [Parh90] 中找到。在这里，我们描述了一种简单直观的方法来导出这些常数。</p>
<p><strong>EXAMPLE 3.5</strong> For  <em>r</em> = 10 and digit set [−5, 9], we need  <em>λ</em> ≥ 5 <em>/</em> 9 and  <em>µ</em> ≥ 1. Given minimal values for  <em>λ</em>  and  <em>µ</em>  that minimize the hardware complexity, we find by choosing the minimal values for  <em>λ</em>  and  <em>µ</em></p>
<p><strong>例 3.5</strong> 对于 r = 10 和数字集 [−5, 9]，我们需要 <span class="arithmatex">\(λ ≥ 5 / 9\)</span> 且 <span class="arithmatex">\(µ ≥ 1\)</span>。给定 λ 和 µ 的最小值以最小化硬件复杂性，我们通过选择 λ 和 µ 的最小值来找到</p>
<div class="arithmatex">\[
\begin{array}{c}
\lambda_{min}=\mu_{min}=1 \text{ 就是说传输的数字是在[-1, 1]中} \\
-\infty=C_{-1} \text{, } -4\le C_0 \le -1\text{, }  6 \le C_1 \le 9\text{, }  C_2=+\infty
\end{array}
\]</div>
<p>We next show how the allowable values for the comparison constant <em>C</em> 1, shown above, are derived. The position sum <em>pi</em> is in [−10, 18]. We can set <em>ti</em>+1 to 1 for <em>pi</em> values as low as 6; for <em>pi</em> = 6, the resulting interim sum of −4 can absorb any incoming transfer in [−1, 1] without falling outside [−5, 9]. On the other hand, we must transfer 1 for <em>pi</em> values of 9 or more. Thus, for <em>pi</em> ≥ <em>C</em> 1, where 6 ≤ <em>C</em> 1 ≤ 9, we choose an outgoing transfer of 1. Similarly, for <em>pi &lt; C</em> 0, we choose an outgoing transfer of −1, where −4 ≤ <em>C</em> 0 ≤ −1. In all other cases, the outgoing transfer is 0.</p>
<p>接下来我们将展示如何导出上面所示的比较常数 <span class="arithmatex">\(C_1\)</span> 的允许值。位置和 <span class="arithmatex">\(p_i\)</span> 在 [−10, 18] 中。对于低至 6 的 <span class="arithmatex">\(p_i\)</span> 值，我们可以将 <span class="arithmatex">\(t_{i+1}\)</span> 设置为 1；对于 <span class="arithmatex">\(p_i = 6\)</span>，所得的临时和 <span class="arithmatex">\(-4\)</span> 可以吸收 [−1, 1] 中的任何传入传输，而不会落在 [−5, 9] 之外。另一方面，当 <span class="arithmatex">\(p_i\)</span> 值为 9 或更大时，我们必须传输 1。因此，对于 <span class="arithmatex">\(p_i ≥ C_1\)</span>，其中 <span class="arithmatex">\(6 ≤ C_1 ≤ 9\)</span>，我们选择传出传输为 1。类似地，对于 <span class="arithmatex">\(p_i &lt; C_0\)</span>，我们选择 <span class="arithmatex">\(-1\)</span> 的传出传输，其中 <span class="arithmatex">\(-4 ≤ C_0 ≤ -1\)</span>。在所有其他情况下，传出传输均为 0。</p>
<p>Assuming that the position sum <em>pi</em> is represented as a 6-bit, 2’s-complement number <em>abcdef</em> , good choices for the comparison constants in the above ranges are <em>C</em> 0 = −4 and <em>C</em> 1 = 8. The logic expressions for the signals <em>g</em> 1 and <em>g</em>−1 then become <em>g</em>−1 = <em>a(</em>¯ <em>c</em> ∨ ¯ <em>d)</em></p>
<p>假设位置和 <span class="arithmatex">\(p_i\)</span> 表示为 6 位、2 的补数 <span class="arithmatex">\(abcdef\)</span> ，则上述范围内的比较常数的较好选择是 <span class="arithmatex">\(C_0 = −4\)</span> 和 <span class="arithmatex">\(C_1 = 8\)</span>。信号 <span class="arithmatex">\(g_1\)</span> 和 <span class="arithmatex">\(g_{−1}\)</span> 的逻辑表达式变为 </p>
<p><span class="arithmatex">\(g_{−1} = a(\overline c \vee \overline d)\)</span>   生成−1 的传输</p>
<p><span class="arithmatex">\(g_1 = \overline a (b \vee c)\)</span>  生成1的转账</p>
<p>An example addition is shown in Fig. 3.11.</p>
<p>图 3.11 显示了另外一个示例。</p>
<p><img alt="image-20230802090151903" src="../assets/image-20230802090151903.png" /></p>
<p>It is proven in [Parh90] that the preceding carry-free addition algorithm is applicable to a redundant representation if and only if one of the following sets of conditions is satisfied:</p>
<p>[Parh90]中证明，当且仅当满足以下一组条件之一时，前述无进位加法算法才适用于冗余表示：</p>
<p><strong>a</strong>. <span class="arithmatex">\(r \gt 2，ρ \ge 3\)</span></p>
<p><strong>b</strong>. <span class="arithmatex">\(r \gt 2，ρ = 2，α \ne 1，β \ne 1\)</span></p>
<p>In other words, the carry-free algorithm is not applicable for  <em>r</em> = 2,  <em>ρ</em> = 1, or  <em>ρ</em> = 2 with  <em>α</em> = 1 or  <em>β</em> = 1. In such cases, a limited-carry addition algorithm is available: </p>
<p>换句话说，无进位算法不适用于 <span class="arithmatex">\(r = 2、ρ = 1\)</span> 或 <span class="arithmatex">\(ρ = 2\)</span>其中 α = 1 或 β = 1。在这种情况下，可以使用有限进位加法算法：</p>
<blockquote>
<p><strong><em>Limited-carry addition algorithm for GSD numbers</em></strong> </p>
<p>Compute the position sums  <em>pi</em> =  <em>xi</em> +  <em>yi</em>. </p>
<p>Compare each  <em>pi</em>  to a constant to determine whether  <em>ei</em>+1 = “low” or “high” ( <em>ei</em>+1 is a binary range estimate for  <em>ti</em>+1). </p>
<p>Given  <em>ei</em>, divide each  <em>pi</em>  into a transfer  <em>ti</em>+1 and an interim sum  <em>wi</em> =  <em>pi</em> −  <em>rti</em>+1. </p>
<p>Add the incoming transfers to obtain the sum digits  <em>si</em> =  <em>wi</em> +  <em>ti</em>. </p>
</blockquote>
<p><center><strong>GSD 数字的有限进位加法算法</strong></center></p>
<ul>
<li>
<p>计算位置总和 <span class="arithmatex">\(p_i = x_i + y_i\)</span>。</p>
</li>
<li>
<p>将每个 <span class="arithmatex">\(p_i\)</span> 与常数进行比较，以确定 <span class="arithmatex">\(e_{i+1}\)</span> =“低”还是“高”（<span class="arithmatex">\(e_{i+1}\)</span> 是 <span class="arithmatex">\(t_{i+1}\)</span> 的二进制范围估计值）。</p>
</li>
<li>
<p>给定 <span class="arithmatex">\(e_i\)</span>，将每个 <span class="arithmatex">\(p_i\)</span> 分为传输 <span class="arithmatex">\(t_{i+1}\)</span> 和临时和 <span class="arithmatex">\(w_i = p_i − rt_{i+1}\)</span>。</p>
</li>
<li>
<p>将传入传输相加以获得数字总和 <span class="arithmatex">\(s_i = w_i + t_i\)</span>。</p>
</li>
</ul>
<p>This “limited-carry” GSD addition algorithm is depicted in Fig. 3.12a; in an alternative implementation (Fig. 3.12b), the “transfer estimate” stage is replaced by another transfer generation/addition phase. </p>
<p>这种“有限进位”GSD 添加算法如图 3.12a 所示；在替代实现中（图3.12b），“传输估计”阶段被另一个传输生成/添加阶段取代。</p>
<p><img alt="image-20230802092045705" src="../assets/image-20230802092045705.png" /></p>
<p>Even though Figs. 3.12a and 3.12b appear similar, they are quite different in terms of the internal designs of the square boxes in the top and middle rows. In both cases, however, the sum digit  <em>si</em>  depends on  <em>xi</em>,  <em>yi</em>,  <em>xi</em>−1,  <em>yi</em>−1,  <em>xi</em>−2, and  <em>yi</em>−2. Rather than wait for the limited transfer propagation from stage  <em>i</em> − 2 to  <em>i</em>, one can try to provide the necessary information directly from stage <em>i</em> − 2 to stage <em>i</em>. This leads to an implementation with parallel carries<span class="arithmatex">\(t_{i+1}^{(1)}\)</span> and <span class="arithmatex">\(t_{i+1}^{(2)}\)</span> from stage <em>i</em>, which is sometimes applicable (Fig. 3.12c).</p>
<p>尽管 3.12a和3.12b看起来很相似，但在顶排和中间排的方框的内部设计方面它们有很大不同。然而，在这两种情况下，总和数字 <span class="arithmatex">\(s_i\)</span> 取决于 <span class="arithmatex">\(x_i、y_i、x_{i−1}、y_{i−1}、x_{i−2}\)</span> 和 <span class="arithmatex">\(y_{i−2}\)</span>。与其等待从第 i − 2 阶段到第 i 阶段的有限传输传播，不如尝试提供必要的信息直接从阶段 <span class="arithmatex">\(i − 2\)</span> 传递到阶段 <span class="arithmatex">\(i\)</span>。这导出一个实现是并行承载来自阶段 <span class="arithmatex">\(i\)</span> 的两个进位<span class="arithmatex">\(t_{i+1}^{(1)}\)</span>和 <span class="arithmatex">\(t_{i+2}^{(2)}\)</span>，这有时是适用的（图 3.12c）。</p>
<p><strong>EXAMPLE 3.6</strong> Figure 3.13 depicts the use of carry estimates in limited-carry addition of radix-2 numbers with the digit set [−1, 1]. Here we have  <em>ρ</em> = 1,  <em>λ</em> min = 1, and  <em>µ</em> min = 1. The “low” and “high” subranges for transfer digits are [−1, 0] and [0, 1], respectively, with a transfer  <em>ti</em>+1 in “high” indicated if  <em>pi</em> ≥ 0. </p>
<p><strong>示例3.6</strong> 图3.13 描述了数字集[−1, 1] 的基2 数的有限进位加法中进位估计的使用。这里我们有 <span class="arithmatex">\(ρ = 1，λ_{min} = 1，μ_{min} = 1\)</span>。传输数字的“低”和“高”子范围分别为 [−1, 0] 和 [0, 1]，如果 <span class="arithmatex">\(p_i ≥ 0\)</span>，则表示“高”中的传输 <span class="arithmatex">\(t_{i+1}\)</span>。</p>
<p><img alt="image-20230802094001317" src="../assets/image-20230802094001317.png" /></p>
<p>图 3.13 通过进位估计对数字集 [−1, 1] 的基 2 数进行有限进位加法。当传入传输位于 [0, 1] 时，位置和 -1 保持不变，而如果传入传输位于 [−1, 0]，则将其重写为 1，进位为 -1。该方案保证 <span class="arithmatex">\(t_i = w_i\)</span>，因此 <span class="arithmatex">\(-1 ≤ s_i ≤ 1\)</span>。</p>
<p><strong>EXAMPLE 3.7</strong> Figure 3.14 shows another example of limited-carry addition with  <em>r</em> = 2, digit set [0, 3],  <em>ρ</em> = 2,  <em>λ</em> min = 0, and  <em>µ</em> min = 3, using carry estimates. The “low” and “high” subranges for transfer digits are [0, 2] and [1, 3], respectively, with a transfer  <em>ti</em>+1 in “high” indicated if  <em>pi</em> ≥ 4. </p>
<p><strong>示例3.7</strong> 图3.14 显示了使用进位估计的限制进位加法的另一个示例，其中<span class="arithmatex">\(r = 2\)</span>、数字集[0, 3]、<span class="arithmatex">\(ρ = 2、λ_{min} = 0 和μ_{min} = 3\)</span>。 传输数字的“高”和“低”子范围分别为 [0, 2] 和 [1, 3]，其中传输 <span class="arithmatex">\(t_{i+1}\)</span> 如果 <span class="arithmatex">\(p_i ≥ 4\)</span>，则表示“高”。</p>
<p><img alt="image-20230802100456905" src="../assets/image-20230802100456905.png" /></p>
<p>图 3.14 通过进位估计对数字集 [0, 3] 的基 2 数进行有限进位加法。当传入传输位于 [0, 2] 时，位置和 1 保持不变，而如果传入传输位于 [1, 3]，则将其重写为 -1，进位为 1。</p>
<p><strong>EXAMPLE 3.8</strong> Figure 3.15 shows the same addition as in Example 3.7 ( <em>r</em> = 2, digit set [0, 3],  <em>ρ</em> = 2,  <em>λ</em> min = 0,  <em>µ</em> min = 3) using the repeated-carry scheme of Fig. 3.12b. </p>
<p><strong>例 3.8</strong> 图 3.15 显示了与例 3.7 相同的加法（ <span class="arithmatex">\(r = 2\)</span>，数字集 [0, 3], <span class="arithmatex">\(ρ = 2, λ_{min} = 0, µ_{min} = 3\)</span>) 使用图 3.12b 的重复进位方案。</p>
<p><img alt="image-20230802120802690" src="../assets/image-20230802120802690.png" /></p>
<p><strong>EXAMPLE 3.9</strong> Figure 3.16 shows the same addition as in Example 3.7 ( <em>r</em> = 2, digit set [0, 3],  <em>ρ</em> = 2,  <em>λ</em> min = 0,  <em>µ</em> min = 3) using the parallel-carries scheme of Fig. 3.12c. </p>
<p><strong>例 3.9</strong> 图 3.16 显示了与例 3.7 相同的加法（ <span class="arithmatex">\(r = 2\)</span>，数字集 [0, 3], <span class="arithmatex">\(ρ = 2, λ_{min} = 0, µ_{min} = 3\)</span>) 使用图 3.12c 的并行进位方案。</p>
<p><img alt="image-20230802120826033" src="../assets/image-20230802120826033.png" /></p>
<p>Subtraction of GSD numbers is very similar to addition. With a symmetric digit set, one can simply invert the signs of all digits in the subtractor  <em>y</em>  to obtain a representation of − <em>y</em> and then perform the addition <em>x</em>+ <em>(</em>− <em>y)</em> using a carry-free or limited-carry algorithm as already discussed. Negation of a GSD number with an asymmetric digit set is somewhat more complicated, but can still be performed by means of a carry-free algorithm [Parh93].</p>
<p>GSD 数字的减法与加法非常相似。对于对称数字集，可以简单地反转减法器 <span class="arithmatex">\(y\)</span> 中所有数字的符号以获得<span class="arithmatex">\(−y\)</span>的表示，然后使用已经讨论过的无进位或有限进位算法执行加法 <span class="arithmatex">\(x+ (− y)\)</span>。具有非对称数字集的 GSD 数的求反稍微复杂一些，但仍然可以通过无进位算法 [Parh93] 来执行。</p>
<p>This algorithm basically converts a radix- <em>r</em> number from the digit set [− <em>β</em>, <em>α</em>], which results from changing the signs of the individual digits of <em>y</em>, to the original digit set [− <em>α</em>, <em>β</em>]. Alternatively, a direct subtraction algorithm can be applied by first computing position differences in [− <em>α</em> − <em>β</em>, <em>α</em> + <em>β</em>], then forming interim differences and transfer digits. Details are omitted here.</p>
<p>基本上该算法是将基数 r 的数从数字集 <span class="arithmatex">\([− β, α]\)</span> 转换为原始数字集<span class="arithmatex">\([− α, β]\)</span>，该数字集是通过更改 y 的各个数字的符号而产生的。或者也可以通过首先计算 [− α − β, α + β] 中的位置差，然后形成临时差并传输数字来应用直接减法算法。此处省略详细内容。</p>
<h2 id="36">3.6 转换和支持功能<a class="headerlink" href="#36" title="Permanent link">&para;</a></h2>
<p>Since input numbers provided from the outside (machine or human interface) are in standard binary or decimal and outputs must be presented in the same way, conversions between binary or decimal and GSD representations are required.</p>
<p>由于从外部（机器或人机界面）提供的输入数字是标准二进制或十进制，并且输出必须以相同的方式呈现，因此需要二进制或十进制与 GSD 表示之间的转换。</p>
<p><strong>EXAMPLE 3.10</strong> Consider number conversions from or to standard binary to or from BSD representation. To convert from signed binary to BSD, we simply attach the common number sign to each digit, if the ( <em>s</em>, <em>v</em>) code of Fig. 3.7 is to be used for the BSD digits. Otherwise, we need a simple digitwise converter from the ( <em>s</em>, <em>v</em>) code to the desired code. To convert from BSD to signed binary, we separate the positive and negative digits into a positive and a negative binary number, respectively. A subtraction then yields the desired result. Here is an example:</p>
<p><strong>示例3.10</strong> 考虑标准二进制与BSD表示之间的数字转换。</p>
<p>为了从有符号二进制转换为 BSD，如果图 3.7 的 (s, v) 代码用于 BSD 数字，我们只需将公共数字符号附加到每个数字上。否则，我们需要一个简单的数字转换器，将 ( s, v) 代码转换为所需的编码。</p>
<p>为了从 BSD 转换为有符号二进制，我们将正数和负数分别分成正二进制数和负二进制数。然后进行减法即可得到所需的结果。这是一个例子：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>1 −1  0 −1  0  +6 的 BSD 表示 BSD representation of +6 
<a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>1  0  0  0  0  正数部分（+1处的位）Positive part (1 digits)
<a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a>0  1  0  1  0  负数部分（−1处的位）Negative part (−1 digits)
<a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a>0  0  1  1  0  差值=转换结果 Difference = conversion result
</code></pre></div>
<p>The positive and negative parts required above are particularly easy to obtain if the BSD number is represented using the ( <em>n</em>, <em>p</em>) code of Fig. 3.7. The reader should be able to modify the process above for dealing with numbers, or deriving results, in 2’s-complement format.</p>
<p>如果 BSD 数字使用图 3.7 的 (n, p) 代码表示的话，上述所需的正负部分特别容易获得。读者应该能够修改上述过程，以 2 的补码格式处理数字或导出结果。</p>
<p>The conversion from redundant to nonredundant representation essentially involves carry propagation and is thus rather slow. It is expected, however, that we will not need conversions very often. Conversion is done at the input and output. Thus, if long sequences of computation are performed between input and output, the conversion overhead can become negligible. </p>
<p>从冗余表示到非冗余表示的转换本质上涉及进位传播，因此相当慢。然而，预计我们不会经常需要转换。转换在输入和输出处完成。因此，如果在输入和输出之间执行长序列的计算，则转换开销可以忽略不计。</p>
<p>Storage overhead (the larger number of bits that may be needed to represent a GSD digit compared to a standard digit in the same radix) used to be a major disadvantage of redundant representations. However, with advances in VLSI (very large-scale integration) technology, this is no longer a major drawback; though the increase in the number of pins for input and output may still be a factor.</p>
<p>存储开销（GSD表示与相同基数中的标准数字表示相比，可能需要的较大位数的数字）曾经是冗余表示的主要缺点。然而，随着VLSI（超大规模集成）技术的进步，这不再是一个主要缺点；尽管输入和输出引脚数量的增加可能仍然是一个因素。</p>
<p>In the rest of this section, we review some properties of GSD representations that are important for the implementation of arithmetic support functions: zero detection, sign test, and overflow handling [Parh93]. </p>
<p>在本节的其余部分中，我们将回顾 GSD 表示的一些对于算术支持函数的实现很重要的属性：零检测、符号测试和溢出处理 [Parh93]。</p>
<p>In a GSD number system, the integer 0 may have multiple representations. For example, the three-digit numbers 0 0 0 and −1 4 0 both represent 0 in radix 4. However, in the special case of  <em>α &lt; r</em>  and  <em>β &lt; r</em>, zero is uniquely represented by the all-0s vector. So despite redundancy and multiple representations, comparison of numbers for equality can be simple in this common special case, since it involves subtraction and detecting the all-0s pattern. </p>
<p>在GSD数字系统中，整数0可以有多种表示形式。例如，三位数 0 0 0 和 −1 4 0 都表示基数 4 中的 0。但是，在 α &lt; r 和 β &lt; r 的特殊情况下，零由全 0 向量唯一表示。因此，尽管存在冗余和多重表示，但在这种常见的特殊情况下，数字比较是否相等可以很简单，因为它涉及减法和检测全 0 模式。</p>
<p>Sign test, and thus any relational comparison ( <em>&lt;</em> , ≤, etc.), is more difficult. The sign of a GSD number in general depends on all its digits. Thus sign test is slow if done through signal propagation (ripple design) or expensive if done by a fast lookahead circuit (contrast this with the trivial sign test for signed-magnitude and 2’s-complement representations). In the special case of  <em>α &lt; r</em>  and  <em>β &lt; r</em>, the sign of a number is identical to the sign of its most significant nonzero digit. Even in this special case, determination of sign requires scanning of all digits, a process that can be as slow as worst-case carry propagation. </p>
<p>符号测试以及任何关系比较（&lt;、≤等）都更加困难。 GSD 编号的符号通常取决于其所有数字。因此，如果通过信号传播（ripple纹波设计）进行符号测试，则速度很慢；如果通过快速先行电路进行，则符号测试成本较高（与符号幅度和 2 补码表示的简单符号测试相比）。在 α &lt; r 和 β &lt; r 的特殊情况下，数字的符号与其最高有效非零数字的符号相同。即使在这种特殊情况下，确定符号也需要扫描所有数字，这个过程可能与最坏情况的进位传播一样慢。</p>
<p>Overflow handling is also more difficult in GSD arithmetic. Consider the addition of two  <em>k</em>-digit numbers. Such an addition produces a transfer-out digit  <em>tk</em> . Since  <em>tk</em>  is produced using the worst-case assumption about the as yet unknown  <em>tk</em>−1, we can get an overflow indication ( <em>tk</em> = 0) even when the result can be represented with  <em>k</em>  digits.  It is possible to perform a test to see whether the overflow is real and, if it is not, to obtain a  <em>k</em>-digit representation for the true result. However, this test and conversion are fairly slow. </p>
<p>GSD 算法中的溢出处理也更加困难。考虑两个 k 位数字的加法。这样的加法产生转出数字tk 。由于 tk 是使用关于未知 tk−1 的最坏情况假设生成的，因此即使结果可以用 k 位数字表示，我们也可以获得溢出指示（ tk = 0）。可以执行测试来查看溢出是否真实，如果不是，则获得真实结果的 k 位表示。然而，这个测试和转换相当缓慢。</p>
<p>The difficulties with sign test and overflow detection can nullify some or all of the speed advantages of GSD number representations. This is why applications of GSD are presently limited to special-purpose systems or to internal number representations, which are subsequently converted to standard representation. </p>
<p>符号测试和溢出检测的困难可能会抵消 GSD 数字表示的部分或全部速度优势。这就是为什么GSD目前仅限于应用在专用系统或内部数字表示，随后就会转换为标准表示。</p>
<h2 id="_1">问题（略）<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h2 id="_2">参考文献和进一步阅读<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>[Aviz61] Avizienis, A., “Signed-Digit Number Representation for Fast Parallel Arithmetic,”
<a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a>         IRE Trans. Electronic Computers, Vol. 10, pp. 389–400, 1961.
<a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>[Glas81] Glaser, A., History of Binary and Other Nondecimal Numeration, rev. ed., Tomash
<a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a>         Publishers, 1981.
<a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a>[Jabe05] Jaberipur, G., B. Parhami, and M. Ghodsi, “Weighted Two-Valued Digit-Set
<a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a>         Encodings: Unifying Efficient Hardware Representation Schemes for Redundant
<a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a>         Number Systems,” IEEE Trans. Circuits and Systems I, Vol. 52, No. 7,
<a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a>         pp. 1348–1357, 2005.
<a id="__codelineno-7-9" name="__codelineno-7-9" href="#__codelineno-7-9"></a>[Jabe06] Jaberipur, G., B. Parhami, and M. Ghodsi, “An Efficient Universal Addition Scheme
<a id="__codelineno-7-10" name="__codelineno-7-10" href="#__codelineno-7-10"></a>         for All Hybrid-Redundant Representations with Weighted Bit-Set Encoding,” J. VLSI
<a id="__codelineno-7-11" name="__codelineno-7-11" href="#__codelineno-7-11"></a>         Signal Processing, Vol. 42, pp. 149–158, 2006.
<a id="__codelineno-7-12" name="__codelineno-7-12" href="#__codelineno-7-12"></a>[Korn94] Kornerup, P., “Digit-Set Conversions: Generalizations and Applications,” IEEE
<a id="__codelineno-7-13" name="__codelineno-7-13" href="#__codelineno-7-13"></a>         Trans. Computers, Vol. 43, No. 8, pp. 622–629, 1994.
<a id="__codelineno-7-14" name="__codelineno-7-14" href="#__codelineno-7-14"></a>[Metz59] Metze, G., and J. E. Robertson, “Elimination of Carry Propagation in Digital
<a id="__codelineno-7-15" name="__codelineno-7-15" href="#__codelineno-7-15"></a>         Computers,” Information Processing ’59 (Proceedings of a UNESCO Conference),
<a id="__codelineno-7-16" name="__codelineno-7-16" href="#__codelineno-7-16"></a>         1960, pp. 389–396.
<a id="__codelineno-7-17" name="__codelineno-7-17" href="#__codelineno-7-17"></a>[Parh88] Parhami, B., “Carry-Free Addition of Recoded Binary Signed-Digit Numbers,” IEEE
<a id="__codelineno-7-18" name="__codelineno-7-18" href="#__codelineno-7-18"></a>         Trans. Computers, Vol. 37, No. 11, pp. 1470–1476, 1988.
<a id="__codelineno-7-19" name="__codelineno-7-19" href="#__codelineno-7-19"></a>[Parh90] Parhami, B., “Generalized Signed-Digit Number Systems: A Unifying Framework for
<a id="__codelineno-7-20" name="__codelineno-7-20" href="#__codelineno-7-20"></a>         Redundant Number Representations,” IEEE Trans. Computers, Vol. 39, No. 1, pp.
<a id="__codelineno-7-21" name="__codelineno-7-21" href="#__codelineno-7-21"></a>         89–98, 1990.
<a id="__codelineno-7-22" name="__codelineno-7-22" href="#__codelineno-7-22"></a>[Parh93] Parhami, B., “On the Implementation of Arithmetic Support Functions for
<a id="__codelineno-7-23" name="__codelineno-7-23" href="#__codelineno-7-23"></a>         Generalized Signed-Digit Number Systems,” IEEE Trans. Computers, Vol. 42, No. 3,
<a id="__codelineno-7-24" name="__codelineno-7-24" href="#__codelineno-7-24"></a>         pp. 379–384, 1993.
<a id="__codelineno-7-25" name="__codelineno-7-25" href="#__codelineno-7-25"></a>[Parh96] Parhami, B., “Comments on ‘High-Speed Area-Efficient Multiplier Design Using
<a id="__codelineno-7-26" name="__codelineno-7-26" href="#__codelineno-7-26"></a>         Multiple-Valued Current Mode Circuits,’” IEEE Trans. Computers, Vol. 45, No. 5,
<a id="__codelineno-7-27" name="__codelineno-7-27" href="#__codelineno-7-27"></a>         pp. 637–638, 1996.
<a id="__codelineno-7-28" name="__codelineno-7-28" href="#__codelineno-7-28"></a>[Parh08] Parhami, B., “Double-Least-Significant-Bits 2’s-Complement Number
<a id="__codelineno-7-29" name="__codelineno-7-29" href="#__codelineno-7-29"></a>         Representation Scheme with Bitwise Complementation and Symmetric Range,” IET
<a id="__codelineno-7-30" name="__codelineno-7-30" href="#__codelineno-7-30"></a>         Circuits, Devices &amp; Systems, Vol. 2, No. 2, pp. 179–186, 2008.
<a id="__codelineno-7-31" name="__codelineno-7-31" href="#__codelineno-7-31"></a>[Phat94] Phatak, D. S., and I. Koren, “Hybrid Signed-Digit Number Systems: A Unified
<a id="__codelineno-7-32" name="__codelineno-7-32" href="#__codelineno-7-32"></a>         Framework for Redundant Number Representations with Bounded Carry Propagation
<a id="__codelineno-7-33" name="__codelineno-7-33" href="#__codelineno-7-33"></a>         Chains,” IEEE Trans. Computers, Vol. 43, No. 8, pp. 880–891, 1994.
<a id="__codelineno-7-34" name="__codelineno-7-34" href="#__codelineno-7-34"></a>[Phat01] Phatak, D. S., T. Goff, and I. Koren, “Constant-Time Addition and Simultaneous
<a id="__codelineno-7-35" name="__codelineno-7-35" href="#__codelineno-7-35"></a>         Format Conversion Based on Redundant Binary Representations,” IEEE Trans.
<a id="__codelineno-7-36" name="__codelineno-7-36" href="#__codelineno-7-36"></a>         Computers, Vol. 50, No. 11, pp. 1267–1278, 2001.
<a id="__codelineno-7-37" name="__codelineno-7-37" href="#__codelineno-7-37"></a>[Tenc06] Tenca, A. F., S. Park, and L. A. Tawalbeh, “Carry-Save Representation Is
<a id="__codelineno-7-38" name="__codelineno-7-38" href="#__codelineno-7-38"></a>         Shift-Unsafe: The Problem and Its Solution,” IEEE Trans. Computers, Vol. 55, No. 5,
<a id="__codelineno-7-39" name="__codelineno-7-39" href="#__codelineno-7-39"></a>         pp. 630–635, 2006
</code></pre></div>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            回到页面顶部
          </button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="页脚" >
        
          
          <a href="../02/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 2. 有符号数的表示" rel="prev">
            <div class="md-footer__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                上一页
              </span>
              <div class="md-ellipsis">
                2. 有符号数的表示
              </div>
            </div>
          </a>
        
        
          
          <a href="../04/" class="md-footer__link md-footer__link--next" aria-label="下一页: 4 剩余数系统" rel="next">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                下一页
              </span>
              <div class="md-ellipsis">
                4 剩余数系统
              </div>
            </div>
            <div class="md-footer__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.action.edit", "content.code.annotate", "content.code.copy", "content.tabs.link", "content.tooltips", "navigation.indexes", "navigation.instant", "navigation.top", "navigation.footer", "navigation.tracking", "search.highlight", "search.share", "search.suggest", "toc.follow"], "search": "../../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.220ee61c.min.js"></script>
      
        
          <script src="../../javascripts/mathjax.js"></script>
        
      
        
          <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        
      
        
          <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
      
        
          <script src="../../javascripts/katex.js"></script>
        
      
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
        
      
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
        
      
    
  </body>
</html>